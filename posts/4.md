Vulkan에서 **파이프라인 배리어**는 GPU 명령 사이의 **메모리·실행 순서**를 보장하는 동기화 장치다.

---

## 1. 왜 필요한가

GPU는 다음을 동시에 한다.

- **파이프라인 스테이지**가 겹쳐서 실행됨 (예: 이전 드로우의 프래그먼트가 돌아가는 동안 다음 드로우의 버텍스가 시작될 수 있음)
- **캐시** 때문에, "쓴 값"이 곧바로 "다음 읽기"에 보이지 않을 수 있음
- **이미지 레이아웃**이 스테이지/용도마다 다름 (예: 전송용 vs 셰이더 샘플링용)

그래서 "여기까지 쓴 작업이 끝난 뒤, 여기부터 읽기/쓰기를 시작해라"를 명시해 주어야 한다. 그걸 **배리어**로 표현한다.

---

## 2. 함수 시그니처 (개념)

```
vkCmdPipelineBarrier(
    commandBuffer,           // 명령을 넣을 커맨드 버퍼
    srcStageMask,           // 이 스테이지들(포함)의 작업이 끝날 때까지 기다림
    dstStageMask,           // 이 스테이지들의 작업은 배리어를 지난 뒤에만 실행됨
    dependencyFlags,        // 배리어 간 의존성 옵션
    memoryBarrierCount,     // 전역 메모리 배리어 개수
    pMemoryBarriers,        // 전역 메모리 배리어 배열
    bufferMemoryBarrierCount,
    pBufferMemoryBarriers,  // 특정 버퍼만 대상
    imageMemoryBarrierCount,
    pImageMemoryBarriers    // 특정 이미지만 대상 (+ 레이아웃 전환)
);
```

- **스테이지 마스크**: "어디까지 끝나야 배리어를 통과하는지(src)" / "배리어 통과 후 어디부터 실행해도 되는지(dst)"를 **파이프라인 스테이지** 단위로 지정.
- **배리어 종류**:
  - **MemoryBarrier**: 모든 메모리(전역).
  - **BufferMemoryBarrier**: 특정 버퍼 구간만.
  - **ImageMemoryBarrier**: 특정 이미지(+ 서브리소스) + **이미지 레이아웃 전환**.

---

## 3. 파이프라인 스테이지 (Pipeline Stage)

작업이 "어느 단계"에 해당하는지 구분하는 비트 플래그다. 배리어는 다음 두 가지로 동기화한다.

- **srcStageMask ("이전")**: **이 스테이지들에 해당하는 작업이 다 끝날 때까지** 기다린다. 끝나야 배리어를 통과한다.
- **dstStageMask ("이후")**: **이 스테이지들에 해당하는 작업은 배리어를 지난 뒤에만** 실행된다. 배리어 앞에서는 시작하지 않는다.

| 스테이지 | 의미 |
|----------|------|
| `TOP_OF_PIPE` | 파이프라인 진입 직후 (아직 실제 작업 전). "아무것도 안 했다"는 표시로 자주 씀. |
| `DRAW_INDIRECT` | 간접 드로우/디스패치 인덱스 읽기 |
| `VERTEX_INPUT` | 버텍스 인덱스/속성 읽기 |
| `VERTEX_SHADER` | 버텍스 셰이더 |
| `TESSELLATION_*` | 테셀레이션 |
| `GEOMETRY_SHADER` | 지오메트리 셰이더 |
| `EARLY_FRAGMENT_TESTS` | 프래그먼트 이전 깊이/스텐실 테스트 |
| `FRAGMENT_SHADER` | 프래그먼트 셰이더 |
| `LATE_FRAGMENT_TESTS` | 프래그먼트 이후 깊이/스텐실 |
| `COLOR_ATTACHMENT_OUTPUT` | 컬러 어태치먼트 쓰기 |
| `COMPUTE_SHADER` | 컴퓨트 셰이더 |
| `TRANSFER` | 복사(copy) 연산 |
| `BOTTOM_OF_PIPE` | 파이프라인 끝. "여기까지 다 끝났다" 표시. |
| `HOST` | CPU가 읽기/쓰기하기 직전·직후 |

- **srcStageMask**: 이 비트로 지정한 스테이지들(포함)에서 일어나는 작업이 **모두 완료될 때까지** 기다린다. 완료되기 전에는 배리어를 통과하지 않는다.
- **dstStageMask**: 배리어 **이후**에 제출된 명령들 중, 이 비트로 지정한 스테이지들에 해당하는 작업은 **배리어를 통과한 뒤에만** 실행된다. 즉, (1) src 스테이지들이 끝날 때까지 대기 → (2) 배리어 통과 → (3) dst 스테이지들이 그다음에 진행.

**스테이지 범위 최소화**: src는 가능한 이른 TOP에 가깝게, dst는 가능한 BOTTOM에 가깝게 두어서 대기를 줄이는 것이 좋다.

---

## 3.1 VkPipelineStageFlagBits — 각 비트 상세

`VkPipelineStageFlagBits`는 위 스테이지 마스크를 구성하는 **개별 비트**다. 여러 비트를 OR해서 `VkPipelineStageFlags`(비트셋)로 넘긴다.

### 실행 순서(개념상)

그래픽 파이프라인에서 명령이 지나가는 흐름은 대략 다음과 같다.

```
TOP_OF_PIPE
    → DRAW_INDIRECT
    → VERTEX_INPUT
    → VERTEX_SHADER
    → TESSELLATION_CONTROL_SHADER → TESSELLATION_EVALUATION_SHADER
    → GEOMETRY_SHADER
    → FRAGMENT_SHADER  (또는 EARLY_FRAGMENT_TESTS → FRAGMENT_SHADER → LATE_FRAGMENT_TESTS)
    → COLOR_ATTACHMENT_OUTPUT
    → BOTTOM_OF_PIPE
```

컴퓨트/전송은 이 흐름과 독립적으로 스테이지가 있다: `COMPUTE_SHADER`, `TRANSFER`, `HOST`.

### 코어 스테이지

| 비트 | 의미 |
|------|------|
| `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` | 파이프라인 최상단. **가상 스테이지**로, "아직 아무 작업도 안 함"을 나타낼 때 씀. src로 쓰면 "이전 명령이 다 끝난 뒤"를 기다리게 할 수 있음. |
| `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT` | `vkCmdDrawIndirect*` / `vkCmdDispatchIndirect*`가 **인디렉트 버퍼를 읽는** 시점. |
| `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT` | 버텍스/인덱스 버퍼 **읽기**. |
| `VK_PIPELINE_STAGE_VERTEX_SHADER_BIT` | 버텍스 셰이더 실행. |
| `VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` | 테셀레이션 컨트롤 셰이더. |
| `VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT` | 테셀레이션 이벨류에이션 셰이더. |
| `VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT` | 지오메트리 셰이더. |
| `VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` | 프래그먼트 셰이더 실행. |
| `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` | 프래그먼트 셰이더 **이전** 깊이·스텐실 테스트/쓰기. |
| `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` | 프래그먼트 셰이더 **이후** 깊이·스텐실 테스트/쓰기. |
| `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` | 컬러 어태치먼트 **쓰기**. |
| `VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT` | 컴퓨트 셰이더 실행. |
| `VK_PIPELINE_STAGE_TRANSFER_BIT` | `vkCmdCopy*` 등 **전송(복사)** 연산. |
| `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT` | 파이프라인 최하단. **가상 스테이지**로, "여기까지 모두 완료"를 나타낼 때 씀. dst로 쓰면 "다음 작업 전체보다 먼저" 실행되게 할 수 있음. |
| `VK_PIPELINE_STAGE_HOST_BIT` | **호스트(CPU)**가 `vkMapMemory` 등으로 읽기/쓰기하는 시점. |

### 집합 스테이지 (편의용)

| 비트 | 의미 |
|------|------|
| `VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT` | 위 그래픽 파이프라인에 등장하는 **모든** 스테이지를 한 번에 지정. "그래픽 전부" 기다리기/통과할 때 사용. |
| `VK_PIPELINE_STAGE_ALL_COMMANDS_BIT` | 그래픽·컴퓨트·전송·호스트 등 **모든 명령**이 지나가는 스테이지를 포함. 가장 넓은 범위. |

### 확장 스테이지 (기능 켜진 경우)

- `TRANSFORM_FEEDBACK_EXT`: 변환 피드백 쓰기.
- `CONDITIONAL_RENDERING_EXT`: 조건부 렌더링에서 조건 버퍼 읽기.
- `RAY_TRACING_*_KHR` / `_NV`: 레이 트레이싱 셰이더·AS 빌드.
- `FRAGMENT_DENSITY_PROCESS_EXT`, `FRAGMENT_SHADING_RATE_*`: VRS/밀도.
- `TASK_SHADER_EXT`, `MESH_SHADER_EXT`: 태스크/메시 셰이더.
- `COMMAND_PREPROCESS_NV`: 커맨드 전처리.

### 가상 스테이지 (TOP / BOTTOM)

- **TOP_OF_PIPE**: 실제 HW 작업은 없고, "파이프라인 진입 직후"를 나타내는 **가상** 스테이지.
  - **src**로 쓰면: "그 이전에 제출된 모든 작업이 완료될 때까지 대기"하는 효과.
- **BOTTOM_OF_PIPE**: "파이프라인 종료 직전"을 나타내는 **가상** 스테이지.
  - **dst**로 쓰면: "배리어 이후의 모든 작업보다 먼저 이 스테이지가 통과"하는 효과.

실제 메모리 액세스가 발생하는 스테이지와 짝을 맞출 때는, "그 액세스를 수행하는 **실제** 스테이지"를 쓰는 것이 좋다. 예: 전송 쓰기 → `TRANSFER`, 셰이더 읽기 → `FRAGMENT_SHADER` 또는 `COMPUTE_SHADER`.

### 배리어에서의 사용 예

- **이미지 레이아웃 전환 (아직 아무도 안 씀 → 전송이 씀)**
  - src: `TOP_OF_PIPE` (이전 작업만 기다림), dst: `TRANSFER`.
- **전송 쓰기 → 셰이더에서 텍스처 읽기**
  - src: `TRANSFER`, dst: `FRAGMENT_SHADER`(또는 해당하는 셰이더 스테이지).
- **렌더 타겟 쓰기 → 다음 패스/컴퓨트에서 읽기**
  - src: `COLOR_ATTACHMENT_OUTPUT`, dst: `FRAGMENT_SHADER` / `COMPUTE_SHADER` 등.

---

## 4. 액세스 마스크 (Access Mask)

"어떤 종류의 읽기/쓰기"를 보장할지 지정한다. **MemoryBarrier / BufferMemoryBarrier / ImageMemoryBarrier** 모두 `srcAccessMask`, `dstAccessMask`를 가진다.

- **srcAccessMask**: 배리어 **이전**에 완료되어야 하는 액세스 종류 (쓰기 위주로 지정).
- **dstAccessMask**: 배리어 **이후**에 일어날 수 있는 액세스 종류 (읽기/쓰기).

예:

- `TRANSFER_WRITE` → 전송(복사) 연산에서 리소스에 쓰기.
- `SHADER_READ` → 셰이더가 텍스처/UBO 등 읽기.
- `SHADER_WRITE` → 셰이더에서 쓰기.
- `COLOR_ATTACHMENT_WRITE` → 컬러 어태치먼트 쓰기.
- `DEPTH_STENCIL_READ/WRITE` 등.

스테이지와 짝을 맞추는 게 중요하다. 예: 전송이 끝난 뒤 셰이더가 읽으려면
`srcStage=TRANSFER`, `srcAccessMask=TRANSFER_WRITE`,
`dstStage=FRAGMENT_SHADER`, `dstAccessMask=SHADER_READ` 같은 식으로 맞춘다.

**실제로 배리어가 걸리는 범위**: 스펙(vkCmdPipelineBarrier Description)에서는 다음처럼 정의한다.

> The first synchronization scope is **limited to** operations on the pipeline stages determined by the source stage mask.  
> The first access scope is **limited to** accesses in the pipeline stages … **Within that**, the first access scope only includes the first access scopes defined by elements of the … memory barriers.

요약하면:

1. **동기화 범위**는 먼저 **스테이지 마스크**로 한정된다.
2. 그 안에서 **access scope**는 배리어에 지정한 **access 타입**(`srcAccessMask` / `dstAccessMask`)으로만 한정된다.

따라서 **“지정한 스테이지에서 일어나는, 지정한 액세스 타입”**만 동기화·캐시 제어 대상이 된다(스테이지와 액세스 둘 다 만족하는 연산만 포함).

- **AccessMask에 넣은 종류의 접근만** 그 배리어에 포함되고, AccessMask에 없는 접근 타입은 의존성/캐시 제어에서 빠진다.
- `VkSubpassDependency`(렌더 패스 내 서브패스 간 의존성)도 같은 원리로, `srcAccessMask` / `dstAccessMask`에 있는 접근 타입만 해당 의존성(배리어)에 포함된다.

---

## 5. dependencyFlags

- `VK_DEPENDENCY_BY_REGION_BIT`: 픽셀/영역 단위로 의존성(같은 영역만 동기화). 렌더 패스 내부에서 자주 씀.
- `VK_DEPENDENCY_VIEW_LOCAL_BIT` 등: 멀티뷰/렌더 패스에서 사용.
- 0: 전체 파이프라인에 걸친 전역 배리어(가장 강한 동기화).

---

## 참고 출처

- **Vulkan Specification – vkCmdPipelineBarrier**  
  https://docs.vulkan.org/refpages/latest/refpages/source/vkCmdPipelineBarrier.html  
  (synchronization scope / access scope “limited to”, “Within that” 문구, Valid Usage)

- **Vulkan Specification – VkMemoryBarrier**  
  https://docs.vulkan.org/refpages/latest/refpages/source/VkMemoryBarrier.html
  (srcAccessMask / dstAccessMask, access scope)

- **Vulkan Specification – VkAccessFlagBits**  
  https://docs.vulkan.org/refpages/latest/refpages/source/VkAccessFlagBits.html  
  (access 타입 정의)

- **Vulkan Samples – Using pipeline barriers efficiently**  
  https://docs.vulkan.org/samples/latest/samples/performance/pipeline_barriers/README.html  
  (src “as early as possible”, dst “as late as possible”, stage 선택 예시)

- **Vulkan Specification – Synchronization and Cache Control**  
  https://docs.vulkan.org/spec/latest/chapters/synchronization.html  
  (동기화·access scope 전체 개념)
