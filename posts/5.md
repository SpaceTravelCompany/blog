**특정 타입 `T`에 대한 배열**에서 "비어 있는 슬롯 하나"를 O(1)로 주고, 다시 반환하는 패턴.  
slice 배열로 구현, **꽉 차면 `add_block`으로 한 블록씩 늘린다.**

---

## 아이디어

- **슬롯 배열** `slots: []T` — 고정 슬라이스 (용량은 init 시 한 번, 부족 시 add_block으로 확장)
- **free stack** `free_idx: []Index` + `free_len: Index` — 비어 있는 인덱스만 스택처럼 보관  
  → 슬롯이 비었는지는 **그 인덱스가 free stack 안에 있는지**로만 판단 (별도 bool 배열 불필요)

할당 = 스택에서 인덱스 하나 pop → O(1). **스택이 비면 `add_block()` 호출 후 다시 pop.**  
반환 = 그 인덱스를 스택에 push → O(1)

---

## 구조체 (고정 슬라이스 + free_len)

```odin
// 한 블록당 슬롯 개수 (확장 시 이 단위로 증가)
Block_Size :: 512

// T: 슬롯에 저장할 타입, Index: 인덱스 타입 (기본 u32)
Slot_Pool :: struct($T: typeid, $Index: typeid = u32) {
	slots:    []T,       // 슬롯 배열 (add_block 시 resize)
	free_idx: []Index,   // free stack: 비어 있는 슬롯 인덱스 목록
	free_len: Index,     // 스택 크기 (유효한 free 개수, pop/push 시 갱신)
}
```

## 프로시저

### 초기화 (첫 블록 하나로 시작)

```odin
// N = Block_Size 개의 슬롯 할당, 전부 free stack에 넣어 둠
slot_pool_init :: proc(p: ^Slot_Pool($T, $Index), allocator := context.allocator) {
	p.slots    = mem.make([]T, Block_Size, allocator)
	p.free_idx = mem.make_non_zeroed([]Index, Block_Size, allocator)
	p.free_len = 0
	for i: Index = 0; i < Block_Size; i += 1 {
		p.free_idx[p.free_len] = i
		p.free_len += 1
	}
}
```

### 슬롯 하나 받기 (O(1)) — 꽉 차면 add_block 후 받기

```odin
// free stack에서 인덱스 하나 pop, 비어 있으면 add_block 후 pop
slot_pool_get :: proc(p: ^Slot_Pool($T, $Index), allocator := context.allocator) -> (index: Index) {
	if p.free_len == 0 do slot_pool_add_block(p, allocator)
	p.free_len -= 1
	index = p.free_idx[p.free_len]
	return index
}
```

### 슬롯 반환 (O(1))

```odin
// 사용 끝난 인덱스를 free stack에 push
slot_pool_put :: proc(p: ^Slot_Pool($T, $Index), index: Index) {
	assert(index >= 0 && index < len(p.slots))
	p.free_idx[p.free_len] = index
	p.free_len += 1
}
```

### 꽉 찼을 때 블록 추가 (add_block)

```odin
// slots/free_idx에 Block_Size만큼 추가하고, 새 인덱스들을 free stack에 넣음
slot_pool_add_block :: proc(p: ^Slot_Pool($T, $Index), allocator := context.allocator) {
	old_len := Index(len(p.slots))
	p.slots    = mem.resize_slice(p.slots,    old_len + Block_Size, allocator)
	p.free_idx = mem.resize_non_zeroed_slice(p.free_idx, old_len + Block_Size, allocator)
	for i: Index = old_len; i < old_len + Block_Size; i += 1 {
		p.free_idx[i] = i
		p.free_len += 1
	}
}
```

---

### 예제

```odin
package main

KEY :: u64
Block_Size :: 512

Slot_Pool :: struct($T: typeid, $Index: typeid = u32) {
	slots:    []T,
	free_idx: []Index,
	free_len: Index,
}

// 제네릭 인스턴스화: 타입 인자로 KEY(타입) 전달 (Odin은 typeid 사용)
array: Slot_Pool(KEY)

// slot_pool_init, slot_pool_get, slot_pool_put, slot_pool_add_block 등 (생략)

main :: proc() {
	slot_pool_init(&array)
	idx := slot_pool_get(&array)
	// 할당받은 슬롯에 접근 (예: 키 값 읽기/쓰기)
	key: KEY = array.slots[idx]

	delete(array.slots)
	delete(array.free_idx)
}
```

## 단점, 주의사항

이 자료구조는 `add_block`으로 확장될 때 `slots`가 `resize_slice`로 재배치되므로, **`&slots[idx]`처럼 슬롯 주소를 들고 있으면 안 됩니다.** 확장 후 해당 포인터는 무효화됩니다.  
해결: `T`를 포인터 타입으로 두거나, 인덱스만 보관하고 필요할 때마다 `slots[idx]`로 접근하거나, 재배치가 없는 풀 구조를 사용하세요. 