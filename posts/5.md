**특정 타입 `T`에 대한 배열**에서 "비어 있는 슬롯 하나"를 O(1)로 주고, 다시 반환하는 패턴.  
slice 배열로 구현, **꽉 차면 `add_block`으로 한 블록씩 늘린다.**

---

## 아이디어

- **슬롯 배열** `slots: []T` — 고정 슬라이스 (용량은 init 시 한 번, 부족 시 add_block으로 확장)
- **free stack** `free_idx: []Index` + `free_len: Index` — 비어 있는 인덱스만 스택처럼 보관  
  → 슬롯이 비었는지는 **그 인덱스가 free stack 안에 있는지**로만 판단 (별도 bool 배열 불필요)

할당 = 스택에서 인덱스 하나 pop → O(1). **스택이 비면 `add_block()` 호출 후 다시 pop.**  
반환 = 그 인덱스를 스택에 push → O(1)

---

## 구조체 (고정 슬라이스 + free_len)

```odin
Block_Size :: 512  // 한 블록당 슬롯 개수

Slot_Pool :: struct($T: typeid, $Index: typeid = u32) {
	slots:    []T,      // 슬롯 배열 (고정 슬라이스, add_block 시 resize)
	free_idx: []Index,   // free stack 저장소 (같이 resize)
	free_len: Index,    // 스택 크기 (현재 유효한 free 개수)
}
```

## 프로시저

### 초기화 (고정 용량 N = Block 한 블록)

```odin
slot_pool_init :: proc(p: ^Slot_Pool($T, $Index), allocator := context.allocator) {
	p.slots    = mem.make([]T, Block_Size, allocator)
	p.free_idx = mem.make_non_zeroed([]Index, Block_Size, allocator)
	p.free_len = 0
	for i: Index = 0; i < Block_Size; i += 1 {
		p.free_idx[p.free_len] = i
		p.free_len += 1
	}
}
```

### 슬롯 하나 받기 (O(1)) — 꽉 차면 add_block 후 받기

```odin
slot_pool_get :: proc(p: ^Slot_Pool($T, $Index), allocator := context.allocator) -> (index: Index) {
	if p.free_len == 0 do slot_pool_add_block(p, allocator)  // 꽉 찼으면 블록 추가
	p.free_len -= 1
	index = p.free_idx[p.free_len]
	return index
}
```

### 슬롯 반환 (O(1))

```odin
slot_pool_put :: proc(p: ^Slot_Pool($T, $Index), index: Index) {
	assert(index >= 0 && index < len(p.slots))
	p.free_idx[p.free_len] = index
	p.free_len += 1
}
```

### 꽉 찼을 때 블록 추가 (add_block)

```odin
slot_pool_add_block :: proc(p: ^Slot_Pool($T, $Index), allocator := context.allocator) {
	old_len := Index(len(p.slots))
	p.slots    = mem.resize_slice(p.slots,    old_len + Block_Size, allocator)
	p.free_idx = mem.resize_non_zeroed_slice(p.free_idx, old_len + Block_Size, allocator)
	for i: Index = old_len; i < old_len + Block_Size; i += 1 {
		p.free_idx[p.free_len] = i
		p.free_len += 1
	}
}
```

---
### 예제
```odin
package main

KEY :: u64
Block_Size :: 512  // 한 블록당 슬롯 개수

Slot_Pool :: struct($T: typeid, $Index: typeid = u32) {
	slots:    []T,      // 슬롯 배열 (고정 슬라이스, add_block 시 resize)
	free_idx: []Index,   // free stack 저장소 (같이 resize)
	free_len: Index,    // 스택 크기 (현재 유효한 free 개수)
}

array : Slot_Pool(key)

//Slot_Pool 함수들..(생략)

main :: proc () {
	slot_pool_init(&array)
	idx := slot_pool_get(&array)
	key:KEY = array.slots[idx]
	
	delete(array.slots)
	delete(array.free_idx)
}
```

## 단점, 주의사항!

이 자료구조는 add_block으로 인해 확장되면 slots 주소가 재배치되기 때문에 &slots[idx] 식으로 포인터 주소를 가져와서 쓰면 안된다. 이를 해결하기 위해서는 T를 포인터 타입으로 두거나 본격적인 풀 자료구조를 사용해야한다. 