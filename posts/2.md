---
title: 모던 C++ 프로그래밍 가이드
---

C++11 이후의 모던 C++ 기능들을 살펴보고, 효율적이고 안전한 코드 작성법을 알아봅니다.

## 모던 C++란?

C++11부터 시작된 "모던 C++"는 더 안전하고, 표현력이 풍부하며, 효율적인 코드 작성을 가능하게 합니다.

## 핵심 기능들

### auto 키워드

```cpp
#include <iostream>
#include <vector>
#include <map>

int main() {
    // 타입 추론
    auto number = 42;           // int
    auto pi = 3.14159;          // double
    auto message = "Hello";     // const char*
    
    // 복잡한 타입에서 유용
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // Range-based for loop
    for (const auto& num : numbers) {
        std::cout << num << " ";
    }
    
    return 0;
}
```

### 스마트 포인터

```cpp
#include <iostream>
#include <memory>

class Resource {
public:
    Resource() { std::cout << "Resource 생성\n"; }
    ~Resource() { std::cout << "Resource 해제\n"; }
    void use() { std::cout << "Resource 사용 중\n"; }
};

int main() {
    // unique_ptr: 단일 소유권
    {
        std::unique_ptr<Resource> ptr1 = std::make_unique<Resource>();
        ptr1->use();
        // 스코프 종료 시 자동 해제
    }
    
    // shared_ptr: 공유 소유권
    {
        std::shared_ptr<Resource> ptr2 = std::make_shared<Resource>();
        std::shared_ptr<Resource> ptr3 = ptr2;  // 참조 카운트 증가
        
        std::cout << "참조 카운트: " << ptr2.use_count() << std::endl;
    }
    
    return 0;
}
```

### 람다 표현식

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3};
    
    // 기본 람다
    auto print = [](int n) { std::cout << n << " "; };
    
    // 캡처를 사용한 람다
    int multiplier = 3;
    auto multiply = [multiplier](int n) { return n * multiplier; };
    
    // 정렬
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a < b;
    });
    
    std::cout << "정렬된 배열: ";
    std::for_each(numbers.begin(), numbers.end(), print);
    std::cout << std::endl;
    
    // 변환
    std::cout << "3배 적용: ";
    for (int n : numbers) {
        std::cout << multiply(n) << " ";
    }
    
    return 0;
}
```

### 구조화된 바인딩 (C++17)

```cpp
#include <iostream>
#include <map>
#include <tuple>

std::tuple<int, std::string, double> getPersonInfo() {
    return {25, "홍길동", 175.5};
}

int main() {
    // 튜플 분해
    auto [age, name, height] = getPersonInfo();
    std::cout << name << ", " << age << "세, " << height << "cm\n";
    
    // map 순회
    std::map<std::string, int> scores = {
        {"국어", 90},
        {"영어", 85},
        {"수학", 95}
    };
    
    for (const auto& [subject, score] : scores) {
        std::cout << subject << ": " << score << "점\n";
    }
    
    return 0;
}
```

### std::optional (C++17)

```cpp
#include <iostream>
#include <optional>
#include <string>

std::optional<std::string> findUser(int id) {
    if (id == 1) {
        return "admin";
    }
    return std::nullopt;  // 값이 없음을 표현
}

int main() {
    auto user1 = findUser(1);
    auto user2 = findUser(999);
    
    if (user1.has_value()) {
        std::cout << "사용자 찾음: " << user1.value() << std::endl;
    }
    
    // value_or로 기본값 제공
    std::cout << "결과: " << user2.value_or("사용자 없음") << std::endl;
    
    return 0;
}
```

## 컴파일

```bash
# C++17 표준으로 컴파일
g++ -std=c++17 -o program main.cpp

# 최적화 및 경고 활성화
g++ -std=c++17 -O2 -Wall -Wextra -o program main.cpp
```

모던 C++를 사용하면 더 안전하고 유지보수하기 쉬운 코드를 작성할 수 있습니다.
